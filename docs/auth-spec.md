# Authentication & Authorization Specification

## 1. Scope & Goals
- Deliver stage 1 of the auth system: email/password sign-up & login, plus groundwork for Google OAuth sign-in.
- Expose authenticated endpoints for the Vue SPA, returning JSON responses with typed payloads.
- Persist members in a relational database with unique email and wear IDs, ready for future roles/admin tooling.
- Ship with repeatable local development tooling (Docker Compose) and automated test coverage (BDD + unit tests).

## 2. Non-Goals
- Password reset, email verification, multi-factor auth (defer to future stages).
- Admin back office UI/permissions (tracked as Stage 4).
- Final decision on token refresh/session strategy (document options, choose in Stage 3).

## 3. Architecture Overview
- **Frontend**: Existing Vite + Vue 3 app. Will call REST JSON endpoints and store returned tokens/client state.
- **Backend service**: Node.js + TypeScript, targeting NestJS (or Express with similar modular structure) using Prisma ORM.
- **Database**: PostgreSQL (Cloud SQL in production, Dockerized Postgres locally).
- **Infrastructure**: Local Docker Compose for `api` + `db`. Production target is GCP (GKE Autopilot or managed k3s) with automated CI/CD pipeline.

## 4. Technology Decisions
- **Language**: TypeScript (strict mode) for backend.
- **Framework**: NestJS preferred for DI and module structure (final confirmation before implementation).
- **ORM**: Prisma for schema management, migrations, and type-safe queries.
- **Testing**:
  - BDD/E2E: `@cucumber/cucumber` + Playwright/Supertest running against local containers.
  - Unit: Jest (or Vitest) for services/controllers.
- **Documentation**: Maintain OpenAPI spec at `docs/openapi.yaml` (initial draft required before coding).

## 5. Data Model
### users
| Column               | Type          | Notes                                  |
|----------------------|---------------|-----------------------------------------|
| id                   | UUID (PK)     | Generated by database                   |
| email                | VARCHAR(255)  | Unique, lower-cased                     |
| password_hash        | TEXT          | bcrypt/argon2 hash (algorithm TBD)      |
| name                 | VARCHAR(120)  | Display name                            |
| wear_id              | VARCHAR(40)   | Unique, immutable slug                  |
| google_id            | VARCHAR(128)  | Nullable, set when linked to Google     |
| newsletter_opt_in    | BOOLEAN       | Defaults true                           |
| role                 | VARCHAR(32)   | Defaults `user`, future `admin`         |
| created_at           | TIMESTAMP     | Default now                             |
| updated_at           | TIMESTAMP     | Updated trigger                         |

Indexes: unique(email), unique(wear_id), unique(google_id) with partial filter.

## 6. API Contract (Stage 1)
All endpoints return JSON and use HTTP status semantics (details finalized during implementation).

### POST /auth/sign-up
- **Request**: `{ email, password, wearId, name, newsletterOptIn }`
- **Validations**: email format, password length ≥ 8, wearId pattern (`^[a-z0-9_]+$`), unique constraints, terms accepted.
- **Response 201**: `{ user: UserResource, tokens: { accessToken } }`
- **Errors**:
  - 409 if email or wearId already exists.
  - 422 for validation issues.

### POST /auth/login
- **Request**: `{ email, password }`
- **Response 200**: `{ user: UserResource, tokens: { accessToken } }`
- **Errors**: 401 for invalid credentials, 423 for locked (future).

### GET /auth/me
- Requires Authorization header.
- **Response 200**: `{ user: UserResource }`

`UserResource` returns: `{ id, email, name, wearId, role, newsletterOptIn, createdAt }` (no sensitive fields).

### Google OAuth (Stage 2 groundwork)
- Reserve routes `/auth/google` (redirect) and `/auth/google/callback` (handles code exchange). Implementation tracked in Stage 2.

## 7. Security & Auth Strategy
- Password hashing algorithm to be finalized (bcrypt rounds vs argon2). Store algorithm metadata for future migrations.
- Tokens: Stage 1 issues short-lived access JWT (15 min). Stage 3 will introduce refresh token or session storage.
- CSRF: Not needed for bearer tokens; if future cookies adopted, integrate CSRF tokens.
- Input sanitization via class-validator / Zod.
- Logging: redact PII (emails, tokens) in logs.

## 8. Testing & QA
- Establish Gherkin features for sign-up and login flows (happy path + failure cases).
- Unit tests for services (user creation, password verification).
- Contract tests verifying OpenAPI schema (e.g., `jest-openapi`).
- CI pipeline runs lint, unit, and Cucumber suites.

## 9. Deployment & Operations
- Local: Docker Compose with `api`, `postgres`, optional `pgadmin`.
- Production: GCP
  - Cloud SQL for Postgres
  - Containerized API (Cloud Build → GKE Autopilot or Cloud Run debate, final decision pending; k3s alternative noted).
  - Secret Manager for JWT secrets, OAuth client credentials.
- Observability: structured logging, health endpoint `/healthz`.

## 10. Milestones & Deliverables
1. **Bootstrap backend repo** – NestJS scaffold, lint/test config, Docker Compose baseline.
2. **Database schema** – Prisma model, migrations, seeding script.
3. **Auth endpoints** – Implement sign-up/login/me, integrate JWT issuance.
4. **API documentation** – Publish OpenAPI and README snippet.
5. **Testing** – Add Cucumber feature tests + unit coverage in CI.
6. **Google OAuth groundwork** – Register routes and configuration placeholders.

## 11. Open Questions
- Confirm final framework choice (NestJS vs Express modular setup).
- Select password hashing algorithm and cost factors.
- Token refresh strategy (JWT refresh vs server-side sessions) for Stage 3.
- Deployment target: GKE Autopilot vs Cloud Run vs custom k3s. Investigate costs + operations.
- Email sending provider for future verification/reset flows.

